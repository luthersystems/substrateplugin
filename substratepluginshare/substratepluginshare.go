package substratepluginshare

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
	"github.com/sirupsen/logrus"
)

// below code to be kept in sync with shiroclient.go

// RequestOptions are operated on by the Config functions generated by
// the With* functions. There is no need for a consumer of this
// library to directly manipulate objects of this type, but this type
// and its fields are public to allow substrateplugin to convert them
// to shiroclient options.
type RequestOptions struct {
	Log                 *logrus.Logger
	LogFields           logrus.Fields
	Headers             map[string]string
	Endpoint            string
	ID                  string
	AuthToken           string
	Params              interface{}
	Transient           map[string][]byte
	Target              *interface{}
	TimestampGenerator  func(context.Context) string
	MSPFilter           []string
	MinEndorsers        int
	Creator             string
	Ctx                 context.Context
	DependentTxID       string
	DisableWritePolling bool
	CCFetchURLDowngrade bool
	CCFetchURLProxy     string
}

// Config is a type for a function that can mutate a requestOptions
// object.
type Config func(*RequestOptions)

// WithContext allows specifying the context to use.
func WithContext(ctx context.Context) Config {
	return func(r *RequestOptions) {
		r.Ctx = ctx
	}
}

// WithLog allows specifying the logger to use.
func WithLog(log *logrus.Logger) Config {
	return func(r *RequestOptions) {
		r.Log = log
	}
}

// WithLogField allows specifying a log field to be included.
func WithLogField(key string, value interface{}) Config {
	return func(r *RequestOptions) {
		r.LogFields[key] = value
	}
}

// WithLogrusFields allows specifying multiple log fields to be
// included.
func WithLogrusFields(fields logrus.Fields) Config {
	return func(r *RequestOptions) {
		for k, v := range fields {
			r.LogFields[k] = v
		}
	}
}

// WithHeader allows specifying an additional HTTP header.
func WithHeader(key string, value string) Config {
	return func(r *RequestOptions) {
		r.Headers[key] = value
	}
}

// WithEndpoint allows specifying the endpoint to target. The RPC
// implementation will not work if an endpoint is not specified.
func WithEndpoint(endpoint string) Config {
	return func(r *RequestOptions) {
		r.Endpoint = endpoint
	}
}

// WithID allows specifying the request ID. If the request ID is not
// specified, a randomly-generated UUID will be used.
func WithID(id string) Config {
	return func(r *RequestOptions) {
		r.ID = id
	}
}

// WithParams allows specifying the phylum "parameters" argument. This
// must be set to something that json.Marshal accepts.
func WithParams(params interface{}) Config {
	return func(r *RequestOptions) {
		r.Params = params
	}
}

// WithTransientData allows specifying a single "transient data"
// key-value pair.
func WithTransientData(key string, val []byte) Config {
	return func(r *RequestOptions) {
		r.Transient[key] = val
	}
}

// WithTransientDataMap allows specifying multiple "transient data"
// key-value pairs.
func WithTransientDataMap(data map[string][]byte) Config {
	return func(r *RequestOptions) {
		for key, val := range data {
			r.Transient[key] = val
		}
	}
}

// WithResponse allows capturing the RPC response for futher analysis.
func WithResponse(target *interface{}) Config {
	return func(r *RequestOptions) {
		r.Target = target
	}
}

// WithAuthToken passes authorization for the transaction issuer with a request
func WithAuthToken(token string) Config {
	return func(r *RequestOptions) {
		r.AuthToken = token
	}
}

// WithTimestampGenerator allows specifying a function that will be
// invoked at every Upgrade, Init, and Call whose output is used to
// set the substrate "now" timestamp in mock mode. Has no effect
// outside of mock mode.
func WithTimestampGenerator(timestampGenerator func(context.Context) string) Config {
	return func(r *RequestOptions) {
		r.TimestampGenerator = timestampGenerator
	}
}

// WithMSPFilter allows specifying the MSP filter. Has no effect in
// mock mode.
func WithMSPFilter(mspFilter []string) Config {
	clonedMSPFilter := append([]string(nil), mspFilter...)
	return (func(r *RequestOptions) {
		r.MSPFilter = clonedMSPFilter
	})
}

// WithMinEndorsers allows specifying the minimum number of endorsing
// peers. Has no effect in mock mode.
func WithMinEndorsers(minEndorsers int) Config {
	return (func(r *RequestOptions) {
		r.MinEndorsers = minEndorsers
	})
}

// WithCreator allows specifying the creator. Only has effect in mock
// mode. Also works in gateway mock mode.
func WithCreator(creator string) Config {
	return (func(r *RequestOptions) {
		r.Creator = creator
	})
}

// WithDependentTxID allows specifying a dependency on a transaction ID.  If
// set, the client will poll for the presence of that transaction before
// simulating the request on the peer with the transaction.
func WithDependentTxID(txID string) Config {
	return (func(r *RequestOptions) {
		r.DependentTxID = txID
	})
}

// WithConditionalDependentTxID allows specifying a conditional dependency on a
// transaction ID when polling is disabled or transaction dependencies are
// already enabled.  This is intended for use with chained sequential calls that
// have a critical dependency.
func WithConditionalDependentTxID(txID string) Config {
	return (func(r *RequestOptions) {
		if r.DisableWritePolling || r.DependentTxID != "" {
			r.DependentTxID = txID
		}
	})
}

// WithDisableWritePolling allows disabling polling for full consensus after a
// write is committed.
func WithDisableWritePolling(disable bool) Config {
	return (func(r *RequestOptions) {
		r.DisableWritePolling = disable
	})
}

// WithCCFetchURLDowngrade allows controlling https -> http downgrade,
// typically useful before proxying for ccfetchurl library.
func WithCCFetchURLDowngrade(downgrade bool) Config {
	return (func(r *RequestOptions) {
		r.CCFetchURLDowngrade = downgrade
	})
}

// WithCCFetchURLProxy sets the proxy for ccfetchurl library.
func WithCCFetchURLProxy(proxy string) Config {
	return (func(r *RequestOptions) {
		r.CCFetchURLProxy = proxy
	})
}

// end code to be kept in sync with shiroclient.go

// Handle represents a handle to a shiroclient instance.
type Handle struct {
	Index int
}

// Response represents a shiroclient response.
type Response struct {
	ResultJSON    []byte
	HasError      bool
	ErrorCode     int
	ErrorMessage  string
	ErrorJSON     []byte
	TransactionID string
}

// UnmarshalTo allows unmarshalling a Response to an interface{}.
func (s *Response) UnmarshalTo(dst interface{}) error {
	if s.HasError {
		return fmt.Errorf("Response had error")
	}
	message, ok := dst.(proto.Message)
	if ok {
		return jsonpb.Unmarshal(bytes.NewReader(s.ResultJSON), message)
	}
	return json.Unmarshal(s.ResultJSON, dst)
}

// Block is a wrapper for summary information about a block.
type Block interface {
	Hash() string
	Transactions() []Transaction
}

// Transaction is a wrapper for summary information about a transaction.
type Transaction interface {
	ID() string
	Reason() string
}
